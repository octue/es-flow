<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modeling &#8212; es_flow 0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index2.html">es_flow 0.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="modeling">
<span id="chapter-modeling-faqs"></span><h1>Modeling<a class="headerlink" href="#modeling" title="Permalink to this headline">Â¶</a></h1>
<ol class="arabic">
<li><p class="first">Use analytical/automatic derivatives.</p>
<p>This is the single most important piece of advice we can give to
you. It is tempting to take the easy way out and use numeric
differentiation. This is a bad idea. Numeric differentiation is
slow, ill-behaved, hard to get right, and results in poor
convergence behaviour.</p>
<p>Ceres allows the user to define templated functors which will
be automatically differentiated. For most situations this is enough
and we recommend using this facility. In some cases the derivatives
are simple enough or the performance considerations are such that
the overhead of automatic differentiation is too much. In such
cases, analytic derivatives are recommended.</p>
<p>The use of numerical derivatives should be a measure of last
resort, where it is simply not possible to write a templated
implementation of the cost function.</p>
<p>In many cases it is not possible to do analytic or automatic
differentiation of the entire cost function, but it is generally
the case that it is possible to decompose the cost function into
parts that need to be numerically differentiated and parts that can
be automatically or analytically differentiated.</p>
<p>To this end, Ceres has extensive support for mixing analytic,
automatic and numeric differentiation. See
<a class="reference internal" href="nnls_modeling.html#_CPPv2N5ceres21CostFunctionToFunctorE" title="ceres::CostFunctionToFunctor"><code class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></code></a>.</p>
</li>
<li><p class="first">When using Quaternions,  consider using <a class="reference internal" href="nnls_modeling.html#_CPPv2N5ceres26QuaternionParameterizationE" title="ceres::QuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></code></a>.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Quaternion">Quaternions</a> are a
four dimensional parameterization of the space of three dimensional
rotations .  However, the  is a three
dimensional set, and so is the tangent space of a
Quaternion. Therefore, it is sometimes (not always) benefecial to
associate a local parameterization with parameter blocks
representing a Quaternion. Assuming that the order of entries in
your parameter block is , you can use
<a class="reference internal" href="nnls_modeling.html#_CPPv2N5ceres26QuaternionParameterizationE" title="ceres::QuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are using <a class="reference external" href="http://eigen.tuxfamily.org/dox/classEigen_1_1Quaternion.html">Eigen&#8217;s Quaternion</a>
object, whose layout is , then you should use
<a class="reference internal" href="nnls_modeling.html#_CPPv2N5ceres31EigenQuaternionParameterizationE" title="ceres::EigenQuaternionParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">EigenQuaternionParameterization</span></code></a>.</p>
</div>
</li>
<li><p class="first">How do I solve problems with general linear &amp; non-linear
<strong>inequality</strong> constraints with Ceres Solver?</p>
<p>Currently, Ceres Solver only supports upper and lower bounds
constraints on the parameter blocks.</p>
<p>A crude way of dealing with inequality constraints is have one or
more of your cost functions check if the inequalities you are
interested in are satisfied, and if not return false instead of
true. This will prevent the solver from ever stepping into an
infeasible region.</p>
<p>This requires that the starting point for the optimization be a
feasible point.  You also risk pre-mature convergence using this
method.</p>
</li>
<li><p class="first">How do I solve problems with general linear &amp; non-linear <strong>equality</strong>
constraints with Ceres Solver?</p>
<p>There is no built in support in ceres for solving problems with
equality constraints.  Currently, Ceres Solver only supports upper
and lower bounds constraints on the parameter blocks.</p>
<p>The trick described above for dealing with inequality
constraints will <strong>not</strong> work for equality constraints.</p>
</li>
<li><p class="first">How do I set one or more components of a parameter block constant?</p>
<p>Using <a class="reference internal" href="nnls_modeling.html#_CPPv2N5ceres22SubsetParameterizationE" title="ceres::SubsetParameterization"><code class="xref cpp cpp-class docutils literal"><span class="pre">SubsetParameterization</span></code></a>.</p>
</li>
<li><p class="first">Putting <a class="reference external" href="http://en.wikipedia.org/wiki/Inverse_function_theorem">Inverse Function Theorem</a> to use.</p>
<p>Every now and then we have to deal with functions which cannot be
evaluated analytically. Computing the Jacobian in such cases is
tricky. A particularly interesting case is where the inverse of the
function is easy to compute analytically. An example of such a
function is the Coordinate transformation between the <a class="reference external" href="http://en.wikipedia.org/wiki/ECEF">ECEF</a> and the <a class="reference external" href="http://en.wikipedia.org/wiki/World_Geodetic_System">WGS84</a> where the
conversion from WGS84 to ECEF is analytic, but the conversion
back to WGS84 uses an iterative algorithm. So how do you compute the
derivative of the ECEF to WGS84 transformation?</p>
<p>One obvious approach would be to numerically
differentiate the conversion function. This is not a good idea. For
one, it will be slow, but it will also be numerically quite
bad.</p>
<p>Turns out you can use the <a class="reference external" href="http://en.wikipedia.org/wiki/Inverse_function_theorem">Inverse Function Theorem</a> in this
case to compute the derivatives more or less analytically.</p>
<p>The key result here is. If , and 
is the invertible Jacobian of  at . Then the
Jacobian , i.e., the Jacobian of
the  is the inverse of the Jacobian of .</p>
<p>Algorithmically this means that given , compute  by whatever means you can. Evaluate the Jacobian of
 at . If the Jacobian matrix is invertible, then
its inverse is the Jacobian of  at  .</p>
<p>One can put this into practice with the following code fragment.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">ecef</span><span class="p">;</span> <span class="c1">// Fill some values</span>
<span class="c1">// Iterative computation.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">lla</span> <span class="o">=</span> <span class="n">ECEFToLLA</span><span class="p">(</span><span class="n">ecef</span><span class="p">);</span>
<span class="c1">// Analytic derivatives</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">lla_to_ecef_jacobian</span> <span class="o">=</span> <span class="n">LLAToECEFJacobian</span><span class="p">(</span><span class="n">lla</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">invertible</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">ecef_to_lla_jacobian</span><span class="p">;</span>
<span class="n">lla_to_ecef_jacobian</span><span class="p">.</span><span class="n">computeInverseWithCheck</span><span class="p">(</span><span class="n">ecef_to_lla_jacobian</span><span class="p">,</span> <span class="n">invertible</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/modeling_faqs.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index2.html">es_flow 0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, T. H. Clark.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>